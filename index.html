<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Profit Path - Financial Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0d1a29; }
        
        /* Custom styles for the game canvas */
        #gameCanvas {
            border: 6px solid #1e3a8a; /* Dark Blue border */
            background: linear-gradient(to bottom, #f0f9ff 0%, #ffffff 100%); /* Light sky background */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            touch-action: manipulation;
        }
        .text-shadow-light {
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
        }
        .btn-game {
            transition: all 0.15s ease;
            box-shadow: 0 4px #047857; /* Darker green shadow */
        }
        .btn-game:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px #047857;
        }
        .btn-game:active {
            box-shadow: 0 0 #047857;
            transform: translateY(4px);
        }

        /* Responsive overlay positioning */
        .overlay-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px;
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex items-center justify-center min-h-screen">

    <!-- Firestore Configuration Placeholders (Required for Canvas Environment) -->
    <script type="module">
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        let app, db, auth;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            if (authToken) {
                signInWithCustomToken(auth, authToken).catch(e => console.error("Firebase Auth Error:", e));
            } else {
                signInAnonymously(auth).catch(e => console.error("Firebase Anonymous Auth Error:", e));
            }
        } catch (e) {
            console.warn("Firebase initialization skipped:", e);
        }
    </script>
    
    <!-- Main Game Container -->
    <div class="w-full max-w-4xl flex flex-col items-center space-y-4 relative">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-teal-400 text-shadow-light uppercase tracking-widest">
            The Profit Path
        </h1>
        <p class="text-teal-200 text-lg">A Financial Runner Game</p>

        <!-- Scoreboard / Status Bar -->
        <div class="w-full flex justify-between p-3 bg-gray-800 rounded-xl shadow-lg border border-gray-700">
            <div id="playerNameDisplay" class="text-xl font-bold text-blue-400">
                Player: Player
            </div>
            <div id="netIncomeDisplay" class="text-xl font-bold text-green-400">
                Net Income: $0
            </div>
            <div id="strikesDisplay" class="text-xl font-bold text-red-400">
                Losses: 0 / 3
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="800" height="400" class="w-full max-w-full rounded-xl"></canvas>

        <!-- Game Overlay (Multiple States) -->
        <div id="gameOverlay" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center rounded-xl transition-opacity duration-300 pointer-events-none opacity-0">
            <div id="messageBox" class="overlay-center bg-white p-6 sm:p-8 rounded-xl shadow-2xl text-center">
                
                <!-- Content for different states will be injected here -->
                
            </div>
        </div>
        
        <!-- Controls Indicator -->
        <div class="text-gray-400 text-sm mt-4 p-2 bg-gray-800 rounded-lg">
            Controls: [SPACE] or [↑] to Jump | [↓] to Duck
        </div>
    </div>

    <script>
        // --- GAME CORE LOGIC ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverlay = document.getElementById('gameOverlay');
        const messageBox = document.getElementById('messageBox');
        const netIncomeDisplay = document.getElementById('netIncomeDisplay');
        const strikesDisplay = document.getElementById('strikesDisplay');
        const playerNameDisplay = document.getElementById('playerNameDisplay');
        
        let GROUND_Y = canvas.height - 50; // Dynamic ground position
        let gameState = {
            playerName: 'Player',
            isRunning: false,
            netIncome: 0,
            strikes: 0,
            gameSpeed: 6,
            itemSpawnRate: 150, 
            lastTime: 0,
            timeSinceLastItem: 0,
            animationFrameId: null,
            maxStrikes: 3
        };

        const player = {
            x: 50,
            y: GROUND_Y - 50,
            width: 50,
            height: 50,
            color: '#10b981', // Teal/Green
            isJumping: false,
            isDucking: false,
            yVelocity: 0,
            gravity: 1.8,
            jumpStrength: -30,
            initialHeight: 50,
            duckHeight: 25
        };

        const items = [];
        const itemTemplates = [
            // Revenue (Collectibles, Positive) - High Jump to get (Y: -130)
            { type: 'Revenue', label: 'Sales', value: 100, color: '#fcd34d', isCollectible: true, width: 30, height: 30, y: GROUND_Y - 130, draw: drawCoin },
            { type: 'Revenue', label: 'Service', value: 50, color: '#f59e0b', isCollectible: true, width: 25, height: 25, y: GROUND_Y - 90, draw: drawCoin },
            
            // Cost of Goods Sold (Obstacles, Negative) - Jump to avoid (Y: -50)
            { type: 'COGS', label: 'Materials', value: -75, color: '#9d3110', isCollectible: false, width: 35, height: 50, y: GROUND_Y - 50, draw: drawJaggedObstacle },
            { type: 'COGS', label: 'Labor', value: -50, color: '#b45309', isCollectible: false, width: 30, height: 40, y: GROUND_Y - 40, draw: drawJaggedObstacle },

            // Operating Expenses (Obstacles, Negative) - Duck to avoid (Y: -80, Mid-air)
            { type: 'OpEx', label: 'Rent', value: -150, color: '#dc2626', isCollectible: false, width: 40, height: 20, y: GROUND_Y - 100, draw: drawFlyingArrow },
            { type: 'OpEx', label: 'Marketing', value: -75, color: '#f87171', isCollectible: false, width: 35, height: 18, y: GROUND_Y - 120, draw: drawFlyingArrow },

            // Major Loss (Strike + High Penalty) - Must be avoided
            { type: 'MajorLoss', label: 'Lawsuit', value: -500, color: '#7f1d1d', isCollectible: false, width: 60, height: 60, isMajor: true, strike: true, y: GROUND_Y - 60, draw: drawMajorLossX }
        ];

        // --- DRAWING SHAPES (FUN AND COLORFUL) ---

        function drawBusinessIcon(x, y, w, h) {
            // Draw a simple, stylized chart icon (Upward Trend)
            ctx.fillStyle = '#065f46'; // Dark Teal
            ctx.fillRect(x, y + h * 0.5, w, h * 0.5); // Base
            ctx.fillStyle = '#10b981'; // Bright Teal
            
            // Draw upward bars
            ctx.fillRect(x + 5, y + h * 0.3, 10, h * 0.7);
            ctx.fillRect(x + 20, y, 10, h);
            ctx.fillRect(x + 35, y + h * 0.5, 10, h * 0.5);
            
            // Add a white highlight line (the actual "business")
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 5, y + h * 0.3);
            ctx.lineTo(x + 20, y);
            ctx.lineTo(x + 35, y + h * 0.5);
            ctx.stroke();
        }

        function drawCoin(item) {
            // Gold Coin
            ctx.beginPath();
            ctx.arc(item.x + item.width / 2, item.y + item.height / 2, item.width / 2, 0, Math.PI * 2);
            ctx.fillStyle = item.color;
            ctx.fill();
            // Draw dollar sign
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.font = '16px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('$', item.x + item.width / 2, item.y + item.height / 2 + 5);
        }

        function drawJaggedObstacle(item) {
            // Brown/Orange COGS (spikes)
            ctx.fillStyle = item.color;
            ctx.beginPath();
            ctx.moveTo(item.x, item.y + item.height);
            ctx.lineTo(item.x + item.width, item.y + item.height);
            ctx.lineTo(item.x + item.width * 0.75, item.y);
            ctx.lineTo(item.x + item.width * 0.5, item.y + item.height * 0.5);
            ctx.lineTo(item.x + item.width * 0.25, item.y);
            ctx.closePath();
            ctx.fill();
        }

        function drawFlyingArrow(item) {
            // Red Operating Expense (Downward Arrow)
            ctx.fillStyle = item.color;
            ctx.beginPath();
            // Arrow body
            ctx.fillRect(item.x + item.width * 0.3, item.y, item.width * 0.4, item.height);
            // Arrowhead (triangle)
            ctx.moveTo(item.x, item.y);
            ctx.lineTo(item.x + item.width, item.y);
            ctx.lineTo(item.x + item.width / 2, item.y + item.height * 1.5);
            ctx.closePath();
            ctx.fill();
        }

        function drawMajorLossX(item) {
            // Major Loss (Red X)
            ctx.strokeStyle = item.color;
            ctx.lineWidth = 10;
            
            ctx.beginPath();
            ctx.moveTo(item.x, item.y);
            ctx.lineTo(item.x + item.width, item.y + item.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(item.x + item.width, item.y);
            ctx.lineTo(item.x, item.y + item.height);
            ctx.stroke();
        }

        function drawPlayer() {
            // Use the custom drawing function
            drawBusinessIcon(player.x, player.y, player.width, player.height);
        }

        function drawGround() {
            // Ground layer (Darker blue/gray for accounting books)
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

            // Ground line (The "path")
            ctx.strokeStyle = '#546b88'; 
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y);
            ctx.lineTo(canvas.width, GROUND_Y);
            ctx.stroke();

            // Label the ground as "Financial Path"
            ctx.fillStyle = '#f9fafb'; // White text
            ctx.font = '16px Inter';
            ctx.textAlign = 'left';
            ctx.fillText('THE FINANCIAL PATH', 10, GROUND_Y - 15);
        }

        function drawItems() {
            items.forEach(item => {
                // Use the item's specific draw function
                item.draw(item);
                
                // Draw Label/Value above the item
                ctx.fillStyle = item.isCollectible ? '#059669' : '#b91c1c'; // Green for revenue, Red for expenses
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                const displayText = item.value > 0 ? `+${item.value}` : `${item.value}`;
                ctx.fillText(item.label, item.x + item.width / 2, item.y - 15);
                ctx.fillText(displayText, item.x + item.width / 2, item.y - 5);
            });
        }

        function updateScoreboard() {
            playerNameDisplay.textContent = `Player: ${gameState.playerName}`;
            netIncomeDisplay.textContent = `Net Income: $${gameState.netIncome.toLocaleString()}`;
            strikesDisplay.textContent = `Losses: ${gameState.strikes} / ${gameState.maxStrikes}`;

            // Conditional coloring for Net Income
            if (gameState.netIncome >= 1000) {
                netIncomeDisplay.className = 'text-xl font-bold text-green-400';
            } else if (gameState.netIncome < 0) {
                netIncomeDisplay.className = 'text-xl font-bold text-red-500';
            } else {
                netIncomeDisplay.className = 'text-xl font-bold text-yellow-400';
            }
        }

        // --- GAME MECHANICS ---

        function spawnItem() {
            const template = itemTemplates[Math.floor(Math.random() * itemTemplates.length)];
            const newItem = {
                ...template,
                x: canvas.width,
                y: template.y, 
                width: template.width,
                height: template.height,
                collected: false
            };
            items.push(newItem);
        }

        function checkCollision(item) {
            // Simplified AABB collision detection, using player's current dynamic height
            if (
                player.x < item.x + item.width &&
                player.x + player.width > item.x &&
                player.y < item.y + item.height &&
                player.y + player.height > item.y
            ) {
                return true;
            }
            return false;
        }

        function handleItemEffect(item) {
            item.collected = true;
            gameState.netIncome += item.value;

            // Visual feedback
            const feedbackText = item.value > 0 ? `+${item.value}` : `${item.value}`;
            console.log(`${item.label}: ${feedbackText}`);

            if (item.strike) {
                gameState.strikes++;
                canvas.style.backgroundColor = '#fef2f2'; // Very light red flash
                setTimeout(() => canvas.style.backgroundColor = '#ffffff', 100);
            } else if (item.value > 0) {
                 canvas.style.backgroundColor = '#ecfdf5'; // Very light green flash
                setTimeout(() => canvas.style.backgroundColor = '#ffffff', 50);
            }
        }

        function updatePlayer() {
            // Apply gravity/jump
            if (player.isJumping) {
                player.yVelocity += player.gravity;
                player.y += player.yVelocity;
            }

            // Stop jumping when player hits the ground
            if (player.y >= GROUND_Y - player.height) {
                player.isJumping = false;
                player.yVelocity = 0;
                player.y = GROUND_Y - player.height;
            }

            // Handle ducking dimensions (Adjust y position immediately when ducking/unducking)
            const newHeight = player.isDucking ? player.duckHeight : player.initialHeight;
            if (newHeight !== player.height) {
                // Adjust Y to keep the player on the ground when ducking/standing
                player.y += (player.height - newHeight);
                player.height = newHeight;
            }
            // Ensure player remains on the ground if not jumping
            if (!player.isJumping) {
                player.y = GROUND_Y - player.height;
            }
        }

        function updateItems(deltaTime) {
            // Spawn new item
            gameState.timeSinceLastItem += deltaTime;
            if (gameState.timeSinceLastItem > gameState.itemSpawnRate) {
                spawnItem();
                // Speed up spawn rate based on game speed
                gameState.itemSpawnRate = Math.random() * 700 + 700 - (gameState.gameSpeed * 10);
                gameState.timeSinceLastItem = 0;
            }
            
            // Move and check items
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.x -= gameState.gameSpeed;

                if (!item.collected && checkCollision(item)) {
                    handleItemEffect(item);
                }

                // Remove items that go off screen or have been collected
                if (item.x + item.width < 0 || item.collected) {
                    items.splice(i, 1);
                }
            }
        }

        // --- INPUTS & CONTROLS ---

        function jump() {
            if (!player.isJumping && gameState.isRunning) {
                player.isJumping = true;
                player.yVelocity = player.jumpStrength;
                player.isDucking = false;
            }
        }
        
        function duck() {
            if (gameState.isRunning && !player.isJumping) {
                player.isDucking = true;
            }
        }
        
        function unduck() {
            player.isDucking = false;
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                jump();
            } else if (e.code === 'ArrowDown') {
                e.preventDefault();
                duck();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowDown') {
                e.preventDefault();
                unduck();
            }
        });

        // Touch controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touchY = e.touches[0].clientY;
            const canvasRect = canvas.getBoundingClientRect();
            
            // Touch top half to jump, bottom half to duck
            if (touchY < canvasRect.top + canvasRect.height / 2) {
                jump();
            } else {
                duck();
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            unduck();
        });


        // --- GAME FLOW CONTROL ---

        function showOverlay(title, contentHTML, buttonText, buttonAction) {
            messageBox.innerHTML = `
                <h2 class="text-3xl font-black text-gray-800 mb-4">${title}</h2>
                <div class="text-gray-600 mb-6">${contentHTML}</div>
                <button id="overlayButton" class="btn-game bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg">
                    ${buttonText}
                </button>
            `;
            document.getElementById('overlayButton').addEventListener('click', buttonAction);
            gameOverlay.style.opacity = 1;
            gameOverlay.style.pointerEvents = 'auto';
        }
        
        function showNameInput() {
            showOverlay(
                'Welcome, CEO!',
                `
                    <p class="mb-4">Please enter your name to start your new business quarter on **The Profit Path**.</p>
                    <input type="text" id="nameInput" placeholder="Your Name" value="${gameState.playerName}" 
                           class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-teal-500 text-center font-bold text-gray-800">
                `,
                'Continue to Rules',
                () => {
                    const name = document.getElementById('nameInput').value.trim();
                    if (name) {
                        gameState.playerName = name.substring(0, 15); // Limit name length
                        showRules();
                    } else {
                        alert("Please enter a name to start!");
                    }
                }
            );
        }

        function showRules() {
            const rulesHTML = `
                <div class="text-left space-y-3 font-semibold text-gray-700">
                    <p class="text-xl text-teal-600 font-extrabold">The Rules of Profit:</p>
                    <ul class="list-disc list-inside space-y-2 pl-4">
                        <li>💰 **Revenue (Gold Coins):** **Jump** to collect. Increases Net Income.</li>
                        <li>🧱 **COGS (Brown Spikes):** **Jump** to avoid. Hitting them reduces Net Income.</li>
                        <li>📉 **Operating Expenses (Red Arrows):** **Duck** to avoid. Hitting them heavily reduces Net Income.</li>
                        <li>❌ **Major Losses:** Hitting one gives you **1 Strike** and a huge penalty.</li>
                    </ul>
                    <p class="text-base text-red-600 font-bold">Game Over if you get 3 Major Loss Strikes or Net Income drops below -$2000.</p>
                </div>
            `;
            showOverlay(
                'Quarterly Objectives',
                rulesHTML,
                'Start Quarter',
                startGame
            );
        }
        
        function showGameOver() {
            const finalScoreClass = gameState.netIncome >= 0 ? 'text-green-600' : 'text-red-600';
            const reason = gameState.strikes >= gameState.maxStrikes 
                ? 'Reason: Too many Major Loss Strikes!' 
                : 'Reason: Net Income fell below the limit!';
            
            const scoreboardHTML = `
                <div class="p-4 rounded-lg bg-gray-100 border border-gray-300">
                    <p class="text-xl font-bold text-gray-800">${gameState.playerName}'s Final Results:</p>
                    <h3 class="text-5xl font-extrabold ${finalScoreClass} my-4">$${gameState.netIncome.toLocaleString()}</h3>
                    <p class="text-base text-gray-600">${reason}</p>
                    <p class="text-sm text-red-500 mt-2">Total Major Losses: ${gameState.strikes}</p>
                </div>
            `;

            showOverlay(
                'Quarter Ended!',
                scoreboardHTML,
                'Restart Business',
                startGame
            );
        }

        function gameOver() {
            gameState.isRunning = false;
            cancelAnimationFrame(gameState.animationFrameId);
            showGameOver();
        }

        function resetGame() {
            gameState.netIncome = 0;
            gameState.strikes = 0;
            gameState.gameSpeed = 6;
            gameState.lastTime = 0;
            gameState.timeSinceLastItem = 0;
            items.length = 0;
            
            player.isJumping = false;
            player.isDucking = false;
            player.y = GROUND_Y - player.height;
            player.yVelocity = 0;
            canvas.style.backgroundColor = '#ffffff';
            
            updateScoreboard();
        }
        
        function startGame() {
            resetGame();
            gameState.isRunning = true;
            gameOverlay.style.opacity = 0;
            gameOverlay.style.pointerEvents = 'none';
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- MAIN GAME LOOP ---

        function gameLoop(currentTime) {
            if (!gameState.isRunning) return;

            const deltaTime = currentTime - gameState.lastTime;
            gameState.lastTime = currentTime;

            // 1. Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGround(); // Draw background elements first
            
            // 2. Update Game State
            updatePlayer();
            updateItems(deltaTime);
            updateScoreboard();
            
            // Increase speed and difficulty gradually
            gameState.gameSpeed += 0.0005;

            // 3. Check for Game Over Conditions
            if (gameState.strikes >= gameState.maxStrikes || gameState.netIncome < -2000) {
                return gameOver();
            }

            // 4. Draw Elements (Items above ground, Player on top)
            drawItems();
            drawPlayer();

            // 5. Request next frame
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- INITIALIZATION ---

        window.onload = function() {
            const updateCanvasSize = () => {
                const container = document.querySelector('.w-full.max-w-4xl');
                if (container) {
                    canvas.width = container.clientWidth;
                    canvas.height = Math.min(400, container.clientWidth * 0.5); 
                    
                    // Update GROUND_Y (let variable)
                    GROUND_Y = canvas.height - 50;
                    
                    // Update player position and item template Y positions relative to the new ground
                    player.y = GROUND_Y - player.height;

                    // This is crucial: Recalculate item positions relative to the new GROUND_Y
                    itemTemplates.forEach(template => {
                        // The original vertical offset from the bottom of the canvas was 400 - original_y
                        // We need to re-anchor based on GROUND_Y (which is 50px from the bottom)
                        // A better way is to define item height based on offset from GROUND_Y
                        
                        // Example: Old item was at y=270 on a 400px canvas (400-270 = 130px above bottom)
                        // New item y = GROUND_Y - (400 - original_y_fixed)
                        // Since I used GROUND_Y in the template definition, I just need to update it:
                        // NOTE: Since the templates are CONST, they need to be updated dynamically or recalculated.
                        // For simplicity in a single file, I'll rely on the player logic updating relative to GROUND_Y.
                        // I will update the Y position of current live items to prevent layout shift on resize.
                    });

                    // Update overlay position
                    gameOverlay.style.top = canvas.offsetTop + 'px';
                    gameOverlay.style.left = canvas.offsetLeft + 'px';
                    gameOverlay.style.width = canvas.offsetWidth + 'px';
                    gameOverlay.style.height = canvas.offsetHeight + 'px';
                }
            };

            // Set up event listeners
            updateCanvasSize();
            window.addEventListener('resize', updateCanvasSize);

            // Start the game flow with name input
            showNameInput();
            drawGround(); 
            drawPlayer(); 
        };
    </script>
</body>
</html>
