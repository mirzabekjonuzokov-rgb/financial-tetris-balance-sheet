<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Profit Path - Financial Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0d1a29; }
        
        #gameCanvas {
            border: 6px solid #1e3a8a; 
            background: linear-gradient(to bottom, #eff6ff 0%, #ffffff 100%); 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            touch-action: manipulation; 
            min-height: 200px;
        }
        .text-shadow-light {
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
        }
        .btn-game {
            transition: all 0.15s ease;
            box-shadow: 0 4px #047857; 
            padding: 12px 24px; 
            border-radius: 8px;
        }
        .btn-game:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px #047857;
        }
        .btn-game:active {
            box-shadow: 0 0 #047857;
            transform: translateY(4px);
        }

        .overlay-center {
            position: fixed; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px;
            z-index: 50;
        }

        .scoreboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px;
        }
        @media (min-width: 640px) {
            .scoreboard {
                flex-direction: row;
                justify-content: space-between;
                gap: initial;
            }
        }
    </style>
</head>
<body class="p-2 sm:p-4 flex items-center justify-center min-h-screen">

    <!-- Firestore Configuration Placeholders (Kept for Canvas environment compatibility) -->
    <script type="module">
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        let app, db, auth;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            if (authToken) {
                signInWithCustomToken(auth, authToken).catch(e => console.error("Firebase Auth Error:", e));
            } else {
                signInAnonymously(auth).catch(e => console.error("Firebase Anonymous Auth Error:", e));
            }
        } catch (e) {
            console.warn("Firebase initialization skipped:", e);
        }
    </script>
    
    <!-- Main Game Container -->
    <div class="w-full max-w-4xl flex flex-col items-center space-y-3 relative">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-teal-400 text-shadow-light uppercase tracking-widest">
            The Profit Path
        </h1>
        <p class="text-teal-200 text-lg">A Financial Runner Game</p>

        <!-- Scoreboard / Status Bar -->
        <div class="scoreboard w-full bg-gray-800 rounded-xl shadow-lg border border-gray-700">
            <div id="playerNameDisplay" class="text-lg font-bold text-blue-400 text-center sm:text-left">
                Player: CEO
            </div>
            <div id="netIncomeDisplay" class="text-lg font-bold text-green-400 text-center">
                Net Income: $0
            </div>
            <div id="strikesDisplay" class="text-lg font-bold text-red-400 text-center sm:text-right">
                Losses: 0 / 3
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="800" height="400" class="w-full max-w-full rounded-xl"></canvas>

        <!-- Game Overlay (Multiple States) -->
        <div id="gameOverlay" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center transition-opacity duration-300 pointer-events-none opacity-0 z-50">
            <div id="messageBox" class="overlay-center bg-white p-6 sm:p-8 rounded-xl shadow-2xl text-center">
                <!-- Content injected by JavaScript -->
            </div>
        </div>
        
        <!-- Controls Indicator - Highly visible for mobile -->
        <div id="controlsHint" class="text-gray-400 text-base mt-2 p-2 bg-gray-800 rounded-lg shadow-md font-semibold w-full text-center">
            <span class="sm:hidden block">üì± Tap **TOP** to **Jump** | Tap **BOTTOM** to **Duck**</span>
            <span class="hidden sm:inline">Controls: [SPACE] or [‚Üë] to Jump | [‚Üì] to Duck</span>
        </div>
    </div>

    <script>
        // --- GAME CORE LOGIC ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverlay = document.getElementById('gameOverlay');
        const messageBox = document.getElementById('messageBox');
        const netIncomeDisplay = document.getElementById('netIncomeDisplay');
        const strikesDisplay = document.getElementById('strikesDisplay');
        const playerNameDisplay = document.getElementById('playerNameDisplay');
        
        let GROUND_Y = canvas.height - 50; 
        const FLOATING_TEXTS = []; 
        let backgroundScroll = { city: 0, hills: 0, road: 0 };
        
        // Player Jump Physics constants
        const INITIAL_JUMP_STRENGTH = -30;
        const BOOST_JUMP_STRENGTH = -45; // Significantly higher jump

        let gameState = {
            playerName: 'CEO',
            isRunning: false,
            netIncome: 0,
            strikes: 0,
            gameSpeed: 6, // Base speed
            itemSpawnRate: 1500, // Initial time in ms
            lastTime: 0,
            timeSinceLastItem: 0,
            animationFrameId: null,
            maxStrikes: 3,
            
            // Invincibility Power-up State
            isInvincible: false, 
            invincibilityTimer: 0, 

            // NEW Jump Boost State
            isJumpBoosted: false, 
            jumpBoostTimer: 0
        };

        const player = {
            x: 50,
            y: GROUND_Y - 50,
            width: 50,
            height: 50,
            color: '#10b981', 
            isJumping: false,
            isDucking: false,
            yVelocity: 0,
            gravity: 1.8,
            jumpStrength: INITIAL_JUMP_STRENGTH, // Uses variable now
            initialHeight: 50,
            duckHeight: 25
        };

        const items = [];
        const itemTemplates = [
            // Revenue (Collectibles)
            // MODIFIED: 'Sales' now grants a jump boost
            { type: 'Revenue', label: 'Sales', value: 150, color: '#fcd34d', isCollectible: true, width: 30, height: 30, yOffset: 130, draw: drawCoin, isJumpBoost: true },
            { type: 'Revenue', label: 'Service', value: 50, color: '#f59e0b', isCollectible: true, width: 25, height: 25, yOffset: 90, draw: drawCoin },
            
            // COGS (Obstacles)
            { type: 'COGS', label: 'Materials', value: -75, color: '#9d3110', isCollectible: false, width: 35, height: 50, yOffset: 50, draw: drawJaggedObstacle },
            { type: 'COGS', label: 'Labor', value: -50, color: '#b45309', isCollectible: false, width: 30, height: 40, yOffset: 40, draw: drawJaggedObstacle },

            // Operating Expenses (Obstacles)
            { type: 'OpEx', label: 'Rent', value: -150, color: '#dc2626', isCollectible: false, width: 40, height: 20, yOffset: 100, draw: drawFlyingArrow },
            { type: 'OpEx', label: 'Marketing', value: -75, color: '#f87171', isCollectible: false, width: 35, height: 18, yOffset: 120, draw: drawFlyingArrow },

            // Major Loss (Strike)
            { type: 'MajorLoss', label: 'Lawsuit', value: -500, color: '#7f1d1d', isCollectible: false, width: 60, height: 60, isMajor: true, strike: true, yOffset: 60, draw: drawMajorLossX },
            
            // Power-up (Tax Refund) - Invincibility
            { type: 'PowerUp', label: 'Tax Refund!', value: 500, color: '#2563eb', isCollectible: true, width: 40, height: 40, yOffset: 150, draw: drawPowerUp, isPowerUp: true, spawnChance: 0.03 } 
        ];

        // --- DRAWING SHAPES ---

        function drawParallaxBackground() {
            const width = canvas.width;
            const height = canvas.height;
            
            // 1. Distant City/Horizon (Slowest)
            const cityColor = '#4b5563';
            const cityY = GROUND_Y - 150;
            const citySpeed = gameState.gameSpeed * 0.1; 
            backgroundScroll.city -= citySpeed;
            if (backgroundScroll.city <= -width) backgroundScroll.city += width;

            ctx.fillStyle = cityColor;
            for (let i = 0; i < 2; i++) {
                const x = backgroundScroll.city + i * width;
                ctx.fillRect(x + 50, cityY - 20, 30, 20);
                ctx.fillRect(x + 100, cityY - 60, 40, 60);
                ctx.fillRect(x + 180, cityY - 40, 20, 40);
                ctx.fillRect(x + 300, cityY - 80, 50, 80);
                ctx.fillRect(x + 400, cityY - 30, 25, 30);
                ctx.fillRect(x + 550, cityY - 70, 40, 70);
            }

            // 2. Rolling Hills (Medium Speed)
            const hillColor = '#6b7280';
            const hillY = GROUND_Y - 40;
            const hillSpeed = gameState.gameSpeed * 0.3;
            backgroundScroll.hills -= hillSpeed;
            if (backgroundScroll.hills <= -width) backgroundScroll.hills += width;
            
            ctx.fillStyle = hillColor;
            ctx.beginPath();
            ctx.moveTo(backgroundScroll.hills, hillY);
            for (let i = 0; i < 3; i++) {
                const x = backgroundScroll.hills + i * (width / 2);
                ctx.bezierCurveTo(x + 50, hillY - 30, x + 150, hillY - 30, x + 200, hillY);
            }
            ctx.lineTo(backgroundScroll.hills + 2 * width, height);
            ctx.lineTo(backgroundScroll.hills, height);
            ctx.closePath();
            ctx.fill();
        }

        function drawBusinessIcon(x, y, w, h) {
            ctx.save();
            
            let primaryColor = '#10b981'; 
            let accentColor = '#065f46'; 
            
            if (gameState.isInvincible) {
                const pulse = gameState.invincibilityTimer % 150 < 75;
                primaryColor = pulse ? '#fcd34d' : '#3b82f6'; 
                accentColor = pulse ? '#d97706' : '#1e40af'; 
            } else if (gameState.isJumpBoosted) {
                 const pulse = gameState.jumpBoostTimer % 100 < 50;
                 primaryColor = pulse ? '#fde047' : '#10b981'; // Quick yellow flash
                 accentColor = pulse ? '#d97706' : '#065f46';
            }

            // 1. Base Structure (Foundation)
            ctx.fillStyle = accentColor; 
            ctx.fillRect(x, y + h * 0.8, w, h * 0.2); 

            // 2. Body/Tower with Gradient
            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);
            gradient.addColorStop(0, primaryColor);
            gradient.addColorStop(1, accentColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(x + 5, y, w - 10, h * 0.8);
            
            // 3. Roofline/Profit Spike
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 5, y + h * 0.2);
            ctx.lineTo(x + w / 2, y);
            ctx.lineTo(x + w - 5, y + h * 0.2);
            ctx.stroke();

            ctx.restore();
        }

        function drawCoin(item) {
            ctx.save();
            ctx.translate(item.x + item.width / 2, item.y + item.height / 2);
            ctx.rotate(gameState.lastTime / 100); 

            // Golden gradient coin
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, item.width / 2);
            gradient.addColorStop(0, '#fde047');
            gradient.addColorStop(1, item.color);

            ctx.beginPath();
            ctx.arc(0, 0, item.width / 2, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('$', 0, 5);

            ctx.restore();
        }
        
        function drawPowerUp(item) {
            ctx.save();
            ctx.translate(item.x + item.width / 2, item.y + item.height / 2);
            ctx.rotate(-gameState.lastTime / 200); 

            // Blue energy diamond
            ctx.fillStyle = '#3b82f6'; 
            ctx.strokeStyle = 'white'; 
            ctx.lineWidth = 2;
            
            const r = item.width / 2;
            
            ctx.beginPath();
            ctx.moveTo(0, -r);
            ctx.lineTo(r, 0);
            ctx.lineTo(0, r);
            ctx.lineTo(-r, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('‚ö°', 0, 7); 

            ctx.restore();
        }

        function drawJaggedObstacle(item) {
            ctx.fillStyle = item.color;
            ctx.beginPath();
            
            ctx.moveTo(item.x, item.y + item.height);
            ctx.lineTo(item.x + item.width, item.y + item.height);
            ctx.lineTo(item.x + item.width * 0.9, item.y);
            ctx.lineTo(item.x + item.width * 0.7, item.y + item.height * 0.5);
            ctx.lineTo(item.x + item.width * 0.5, item.y);
            ctx.lineTo(item.x + item.width * 0.3, item.y + item.height * 0.5);
            ctx.lineTo(item.x + item.width * 0.1, item.y);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#374151';
            ctx.stroke();
        }

        function drawFlyingArrow(item) {
            ctx.fillStyle = item.color;
            ctx.save();
            ctx.translate(item.x + item.width / 2, item.y + item.height / 2);
            ctx.rotate(0.1); 
            
            // Arrow Body
            ctx.fillRect(-item.width / 2, -item.height / 4, item.width * 0.8, item.height / 2);

            // Arrow Head
            ctx.beginPath();
            ctx.moveTo(item.width * 0.3, -item.height / 2);
            ctx.lineTo(item.width / 2, 0);
            ctx.lineTo(item.width * 0.3, item.height / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }

        function drawMajorLossX(item) {
            ctx.strokeStyle = item.color;
            ctx.lineWidth = 12;
            
            ctx.beginPath();
            ctx.moveTo(item.x, item.y);
            ctx.lineTo(item.x + item.width, item.y + item.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(item.x + item.width, item.y);
            ctx.lineTo(item.x, item.y + item.height);
            ctx.stroke();

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(item.x + item.width * 0.1, item.y + item.height * 0.1);
            ctx.lineTo(item.x + item.width * 0.9, item.y + item.height * 0.9);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(item.x + item.width * 0.9, item.y + item.height * 0.1);
            ctx.lineTo(item.x + item.width * 0.1, item.y + item.height * 0.9);
            ctx.stroke();
        }
        
        function drawPlayer() {
            drawBusinessIcon(player.x, player.y, player.width, player.height);
        }

        function drawGround() {
            const width = canvas.width;
            const height = canvas.height;
            const roadSpeed = gameState.gameSpeed * 1.5;
            
            // 1. Solid Road
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, GROUND_Y, width, height - GROUND_Y);

            // 2. Road Lines (Fastest scrolling element)
            const lineHeight = 5;
            const lineGap = 40;
            const lineLength = 20;

            backgroundScroll.road -= roadSpeed;
            if (backgroundScroll.road <= -lineGap) backgroundScroll.road += lineGap;

            ctx.fillStyle = '#fde047'; 
            for (let i = 0; i < width / lineGap + 2; i++) {
                const x = (i * lineGap) + backgroundScroll.road;
                ctx.fillRect(x, GROUND_Y + 20, lineLength, lineHeight);
            }
        }

        function drawItems() {
            items.forEach(item => {
                item.draw(item);
                
                // Draw label/value
                ctx.fillStyle = item.value > 0 ? '#059669' : '#b91c1c'; 
                ctx.font = 'bold 10px Inter';
                ctx.textAlign = 'center';
                const displayText = item.value > 0 ? `+${item.value}` : `${item.value}`;
                ctx.fillText(item.label, item.x + item.width / 2, item.y - 15);
                ctx.fillText(displayText, item.x + item.width / 2, item.y - 5);
            });
        }
        
        function drawFloatingText() {
            for (let i = FLOATING_TEXTS.length - 1; i >= 0; i--) {
                const textObj = FLOATING_TEXTS[i];
                textObj.life--;
                textObj.y -= 1.5; 
                textObj.opacity = textObj.life / 100; 

                ctx.fillStyle = textObj.color.replace(')', `, ${textObj.opacity})`);
                ctx.font = 'bold 22px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(textObj.text, textObj.x, textObj.y);

                if (textObj.life <= 0) {
                    FLOATING_TEXTS.splice(i, 1);
                }
            }
        }


        function updateScoreboard() {
            playerNameDisplay.textContent = `Player: ${gameState.playerName}`;
            netIncomeDisplay.textContent = `Net Income: $${gameState.netIncome.toLocaleString()}`;
            strikesDisplay.textContent = `Losses: ${gameState.strikes} / ${gameState.maxStrikes}`;

            // Update color based on score
            if (gameState.netIncome >= 1000) {
                netIncomeDisplay.className = 'text-lg font-bold text-green-400 text-center';
            } else if (gameState.netIncome < 0) {
                netIncomeDisplay.className = 'text-lg font-bold text-red-500 text-center';
            } else {
                netIncomeDisplay.className = 'text-lg font-bold text-yellow-400 text-center';
            }
            
            // Show power-up statuses
            if (gameState.isInvincible) {
                 netIncomeDisplay.textContent += ` (üõ°Ô∏è ${Math.ceil(gameState.invincibilityTimer / 1000)}s)`;
            } else if (gameState.isJumpBoosted) {
                 netIncomeDisplay.textContent += ` (‚¨ÜÔ∏è ${Math.ceil(gameState.jumpBoostTimer / 1000)}s)`;
            }
        }

        // --- GAME MECHANICS ---

        function spawnItem() {
            let availableTemplates = itemTemplates.filter(t => !t.isPowerUp || Math.random() < (t.spawnChance || 0.05));
            if (availableTemplates.length === 0) availableTemplates = itemTemplates.filter(t => !t.isPowerUp); 

            const template = availableTemplates[Math.floor(Math.random() * availableTemplates.length)];
            
            const newItem = {
                ...template,
                x: canvas.width,
                y: GROUND_Y - template.yOffset, 
                width: template.width,
                height: template.height,
                collected: false
            };
            items.push(newItem);
        }

        function checkCollision(item) {
            return (
                player.x < item.x + item.width &&
                player.x + player.width > item.x &&
                player.y < item.y + item.height &&
                player.y + player.height > item.y
            );
        }

        function triggerVibration(duration) {
            if ("vibrate" in navigator) {
                navigator.vibrate(duration);
            }
        }

        function handleItemEffect(item) {
            item.collected = true;

            // Invincibility check: If invincible, only process positive effects
            if (!item.isCollectible && gameState.isInvincible) {
                FLOATING_TEXTS.push({ 
                    x: item.x + item.width / 2, 
                    y: item.y, 
                    text: 'SHIELDED!', 
                    color: 'rgba(59, 130, 246', 
                    life: 90 
                });
                triggerVibration(50); 
                return;
            }

            // Normal effect processing
            gameState.netIncome += item.value;
            
            const textValue = item.value > 0 ? `+$${item.value}` : `-$${Math.abs(item.value)}`;
            const textColor = item.value > 0 ? 'rgba(16, 185, 129' : 'rgba(239, 68, 68';

            FLOATING_TEXTS.push({ 
                x: player.x + player.width / 2, 
                y: player.y, 
                text: `${item.label} ${textValue}`, 
                color: textColor, 
                life: 120 
            });


            if (item.isPowerUp) {
                // Invincibility Power-up
                gameState.isInvincible = true;
                gameState.invincibilityTimer = 5000; 
                triggerVibration(300); 
                FLOATING_TEXTS.push({ 
                    x: player.x + player.width / 2, 
                    y: player.y - 40, 
                    text: 'INVINCIBLE!', 
                    color: 'rgba(59, 130, 246', 
                    life: 180 
                });
            }
            
            if (item.isJumpBoost) {
                // Jump Boost Power-up
                gameState.isJumpBoosted = true;
                gameState.jumpBoostTimer = 3000; // 3 seconds boost
                player.jumpStrength = BOOST_JUMP_STRENGTH;
                triggerVibration(100); 
                FLOATING_TEXTS.push({ 
                    x: player.x + player.width / 2, 
                    y: player.y - 40, 
                    text: 'JUMP BOOST!', 
                    color: 'rgba(252, 211, 77', 
                    life: 180 
                });
            }

            if (item.strike) {
                gameState.strikes++;
                canvas.style.backgroundColor = '#fef2f2'; 
                setTimeout(() => canvas.style.backgroundColor = '#ffffff', 100);
                triggerVibration(500); 
            } else if (item.value > 0) {
                 canvas.style.backgroundColor = '#ecfdf5'; 
                setTimeout(() => canvas.style.backgroundColor = '#ffffff', 50);
            }
        }

        function updatePlayer() {
            // Apply gravity/jump
            if (player.isJumping) {
                player.yVelocity += player.gravity;
                player.y += player.yVelocity;
            }

            if (player.y >= GROUND_Y - player.height) {
                player.isJumping = false;
                player.yVelocity = 0;
                player.y = GROUND_Y - player.height; 
            }

            // Handle ducking dimensions
            const newHeight = player.isDucking ? player.duckHeight : player.initialHeight;
            if (newHeight !== player.height) {
                player.y += (player.height - newHeight);
                player.height = newHeight;
            }
            if (!player.isJumping) {
                player.y = GROUND_Y - player.height;
            }
        }

        function updateItems(deltaTime) {
            gameState.timeSinceLastItem += deltaTime;
            if (gameState.timeSinceLastItem > gameState.itemSpawnRate) {
                spawnItem();
                gameState.itemSpawnRate = Math.random() * 800 + 800 - (gameState.gameSpeed * 10);
                gameState.timeSinceLastItem = 0;
            }
            
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.x -= gameState.gameSpeed;

                if (!item.collected && checkCollision(item)) {
                    handleItemEffect(item);
                }

                if (item.x + item.width < 0 || item.collected) {
                    items.splice(i, 1);
                }
            }
        }
        
        function updateInvincibility(deltaTime) {
            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= deltaTime;
                if (gameState.invincibilityTimer <= 0) {
                    gameState.isInvincible = false;
                    gameState.invincibilityTimer = 0;
                }
            }
        }

        function updateJumpBoost(deltaTime) {
            if (gameState.isJumpBoosted) {
                gameState.jumpBoostTimer -= deltaTime;
                if (gameState.jumpBoostTimer <= 0) {
                    gameState.isJumpBoosted = false;
                    gameState.jumpBoostTimer = 0;
                    // Reset jump strength to normal
                    player.jumpStrength = INITIAL_JUMP_STRENGTH; 
                }
            }
        }


        // --- INPUTS & CONTROLS ---

        function jump() {
            if (!player.isJumping && gameState.isRunning) {
                player.isJumping = true;
                player.yVelocity = player.jumpStrength; // Uses dynamic jumpStrength
                player.isDucking = false;
                triggerVibration(20);
            }
        }
        
        function duck() {
            if (gameState.isRunning && !player.isJumping) {
                player.isDucking = true;
            }
        }
        
        function unduck() {
            player.isDucking = false;
        }

        // Desktop Key Controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                jump();
            } else if (e.code === 'ArrowDown') {
                e.preventDefault();
                duck();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowDown') {
                e.preventDefault();
                unduck();
            }
        });

        // Mobile Touch Controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touchY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
            
            if (touchY < canvas.height / 2) {
                jump();
            } else {
                duck();
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            unduck();
        });


        // --- GAME FLOW CONTROL ---

        function showOverlay(title, contentHTML, buttonText, buttonAction) {
            messageBox.innerHTML = `
                <h2 class="text-3xl font-black text-gray-800 mb-4">${title}</h2>
                <div class="text-gray-600 mb-6">${contentHTML}</div>
                <button id="overlayButton" class="btn-game bg-teal-600 hover:bg-teal-700 text-white font-bold rounded-lg shadow-lg">
                    ${buttonText}
                </button>
            `;
            document.getElementById('overlayButton').addEventListener('click', buttonAction);
            gameOverlay.style.opacity = 1;
            gameOverlay.style.pointerEvents = 'auto';
        }
        
        function showNameInput() {
            showOverlay(
                'Welcome, CEO!',
                `
                    <p class="mb-4">Enter your name to start your quarter on **The Profit Path**.</p>
                    <input type="text" id="nameInput" placeholder="Your Name" value="${gameState.playerName}" 
                           class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-teal-500 text-center font-bold text-gray-800">
                `,
                'Continue to Rules',
                () => {
                    const name = document.getElementById('nameInput').value.trim();
                    if (name) {
                        gameState.playerName = name.substring(0, 15);
                        showRules();
                    } else {
                        messageBox.querySelector('p').innerHTML = '<p class="text-red-500 mb-4 font-bold">Please enter a name to start!</p>';
                    }
                }
            );
        }

        function showRules() {
            const rulesHTML = `
                <div class="text-left space-y-3 font-semibold text-gray-700 text-sm sm:text-base">
                    <p class="text-xl text-teal-600 font-extrabold text-center">Quarterly Objectives (Rules):</p>
                    <ul class="list-disc list-inside space-y-2 pl-4">
                        <li>üí∞ **Revenue (Coins):** **Jump (Tap Top)** to collect. Increases Net Income.</li>
                        <li>üöÄ **Sales (Yellow Coin):** Grants high revenue AND a temporary **Jump Boost**!</li>
                        <li>üß± **COGS/Expenses (Spikes/Arrows):** **Avoid** by Jumping or Ducking.</li>
                        <li>üü¶ **Tax Refund (Blue Diamond):** Grants a bonus and temporary **Invincibility**.</li>
                        <li>‚ùå **Major Losses:** Hitting one gives you **1 Strike** (Max 3).</li>
                    </ul>
                    <p class="text-base text-red-600 font-bold mt-4 text-center">Goal: Maximize Net Income!</p>
                </div>
            `;
            showOverlay(
                'Financial Strategy',
                rulesHTML,
                'Start Quarter',
                startGame
            );
        }
        
        function showGameOver() {
            const finalScoreClass = gameState.netIncome >= 0 ? 'text-green-600' : 'text-red-600';
            const reason = gameState.strikes >= gameState.maxStrikes 
                ? 'Reason: Too many Major Loss Strikes!' 
                : 'Reason: Net Income fell too low!';
            
            const scoreboardHTML = `
                <div class="p-4 rounded-lg bg-gray-100 border border-gray-300">
                    <p class="text-xl font-bold text-gray-800">${gameState.playerName}'s Final Results:</p>
                    <h3 class="text-5xl font-extrabold ${finalScoreClass} my-4">$${gameState.netIncome.toLocaleString()}</h3>
                    <p class="text-base text-gray-600">${reason}</p>
                    <p class="text-sm text-red-500 mt-2">Total Major Losses: ${gameState.strikes}</p>
                </div>
            `;

            showOverlay(
                'Quarter Ended!',
                scoreboardHTML,
                'Restart Business',
                startGame
            );
        }

        function gameOver() {
            gameState.isRunning = false;
            cancelAnimationFrame(gameState.animationFrameId);
            showGameOver();
        }

        function resetGame() {
            gameState.netIncome = 0;
            gameState.strikes = 0;
            gameState.gameSpeed = 6;
            gameState.lastTime = 0;
            gameState.timeSinceLastItem = 0;
            
            // Reset all power-up states
            gameState.isInvincible = false;
            gameState.invincibilityTimer = 0;
            gameState.isJumpBoosted = false;
            gameState.jumpBoostTimer = 0;
            player.jumpStrength = INITIAL_JUMP_STRENGTH; 

            items.length = 0;
            FLOATING_TEXTS.length = 0;
            backgroundScroll = { city: 0, hills: 0, road: 0 };
            
            player.isJumping = false;
            player.isDucking = false;
            player.y = GROUND_Y - player.height;
            player.yVelocity = 0;
            
            updateScoreboard();
        }
        
        function startGame() {
            resetGame();
            gameState.isRunning = true;
            gameOverlay.style.opacity = 0;
            gameOverlay.style.pointerEvents = 'none';
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- MAIN GAME LOOP ---

        function gameLoop(currentTime) {
            if (!gameState.isRunning) return;

            const deltaTime = currentTime - gameState.lastTime;
            gameState.lastTime = currentTime;
            
            const dtSeconds = deltaTime / 1000;

            // 1. Update Game State
            updateInvincibility(deltaTime);
            updateJumpBoost(deltaTime); // Process jump boost timer
            updatePlayer();
            updateItems(deltaTime);
            updateScoreboard();
            
            gameState.gameSpeed += 0.5 * dtSeconds; 

            // 2. Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 3. Draw Elements 
            drawParallaxBackground();
            drawGround(); 
            drawItems();
            drawPlayer();
            drawFloatingText(); 
            
            // 4. Check for Game Over Conditions
            if (gameState.strikes >= gameState.maxStrikes || gameState.netIncome < -2000) {
                return gameOver();
            }

            // 5. Request next frame
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- INITIALIZATION ---

        window.onload = function() {
            const updateCanvasSize = () => {
                const container = document.querySelector('.w-full.max-w-4xl');
                if (container) {
                    canvas.width = container.clientWidth;
                    canvas.height = Math.min(400, container.clientWidth * 0.5); 
                    
                    GROUND_Y = canvas.height - 50;
                    player.y = GROUND_Y - player.height;
                }
            };

            updateCanvasSize();
            window.addEventListener('resize', updateCanvasSize);

            drawParallaxBackground();
            drawGround();
            drawPlayer(); 
            
            showNameInput();
        };
    </script>
</body>
</html>
