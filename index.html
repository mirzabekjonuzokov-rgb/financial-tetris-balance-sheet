<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Profit Path - Financial Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0d1a29; }
        
        #gameCanvas {
            border: 6px solid #1e3a8a; 
            background: linear-gradient(to bottom, #eff6ff 0%, #ffffff 100%); 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            touch-action: none; /* Disable default touch actions */
            min-height: 200px;
        }
        .text-shadow-light {
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
        }
        .btn-game {
            transition: all 0.15s ease;
            box-shadow: 0 4px #047857; 
            padding: 12px 24px; 
            border-radius: 8px;
        }
        .btn-game:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px #047857;
        }
        .btn-game:active {
            box-shadow: 0 0 #047857;
            transform: translateY(4px);
        }

        .overlay-center {
            position: fixed; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 550px;
            z-index: 50;
        }
        
        .char-card {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .char-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        .char-card.selected {
            border-color: #065f46;
            background-color: #ecfdf5;
            box-shadow: 0 0 0 4px #065f46;
        }

        .scoreboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px;
        }
        @media (min-width: 640px) {
            .scoreboard {
                flex-direction: row;
                justify-content: space-between;
                gap: initial;
            }
        }
    </style>
</head>
<body class="p-2 sm:p-4 flex items-center justify-center min-h-screen">

    <!-- Firestore Configuration Placeholders (Kept for Canvas environment compatibility) -->
    <script type="module">
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        let app, db, auth;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            if (authToken) {
                signInWithCustomToken(auth, authToken).catch(e => console.error("Firebase Auth Error:", e));
            } else {
                signInAnonymously(auth).catch(e => console.error("Firebase Anonymous Auth Error:", e));
            }
        } catch (e) {
            console.warn("Firebase initialization skipped:", e);
        }
    </script>
    
    <!-- Main Game Container -->
    <div class="w-full max-w-4xl flex flex-col items-center space-y-3 relative">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-teal-400 text-shadow-light uppercase tracking-widest">
            The Profit Path
        </h1>
        <p class="text-teal-200 text-lg">A Financial Runner Game</p>

        <!-- Scoreboard / Status Bar -->
        <div class="scoreboard w-full bg-gray-800 rounded-xl shadow-lg border border-gray-700">
            <div id="playerNameDisplay" class="text-lg font-bold text-blue-400 text-center sm:text-left">
                Player: CEO
            </div>
            <div id="netIncomeDisplay" class="text-lg font-bold text-green-400 text-center">
                Net Income: $0
            </div>
            <div id="strikesDisplay" class="text-lg font-bold text-red-400 text-center sm:text-right">
                Losses: 0 / 3
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="800" height="400" class="w-full max-w-full rounded-xl"></canvas>

        <!-- Game Overlay (Multiple States) -->
        <div id="gameOverlay" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center transition-opacity duration-300 pointer-events-none opacity-0 z-50">
            <div id="messageBox" class="overlay-center bg-white p-6 sm:p-8 rounded-xl shadow-2xl text-center">
                <!-- Content injected by JavaScript -->
            </div>
        </div>
        
        <!-- Controls Indicator - Highly visible for mobile -->
        <div id="controlsHint" class="text-gray-400 text-base mt-2 p-2 bg-gray-800 rounded-lg shadow-md font-semibold w-full text-center">
            <span class="sm:hidden block">üì± Tap **TOP** to **Jump** | Tap **BOTTOM** to **Duck**</span>
            <span class="hidden sm:inline">Controls: [SPACE] or [‚Üë] to Jump | [‚Üì] to Duck</span>
        </div>
    </div>

    <script>
        // --- GAME CORE LOGIC ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverlay = document.getElementById('gameOverlay');
        const messageBox = document.getElementById('messageBox');
        const netIncomeDisplay = document.getElementById('netIncomeDisplay');
        const strikesDisplay = document.getElementById('strikesDisplay');
        const playerNameDisplay = document.getElementById('playerNameDisplay');
        
        let GROUND_Y = canvas.height - 50; 
        const FLOATING_TEXTS = []; 
        let backgroundScroll = { city: 0, hills: 0, road: 0 };
        
        // Base Jump Physics constants
        const INITIAL_JUMP_STRENGTH = -30;
        const BOOST_JUMP_STRENGTH = -45; // Jump boost effect
        const SPEED_BOOST_FACTOR = 1.6; // Speed boost effect

        const characterTemplates = {
            'CEO': {
                name: 'The CEO',
                emoji: 'üëî',
                baseSpeed: 4.5,
                baseJumpStrength: INITIAL_JUMP_STRENGTH,
                incomeMultiplier: 1.0,
                desc: 'Balanced leadership. Ready for anything.'
            },
            'TECH_LEAD': {
                name: 'The Tech Lead',
                emoji: 'üíª',
                baseSpeed: 5.5, // Faster base speed
                baseJumpStrength: -25, // Shorter jump
                incomeMultiplier: 1.0,
                desc: 'Fast-paced, high execution speed. Needs momentum.'
            },
            'ACCOUNTANT': {
                name: 'The Accountant',
                emoji: 'üßÆ',
                baseSpeed: 3.5, // Slower base speed
                baseJumpStrength: INITIAL_JUMP_STRENGTH,
                incomeMultiplier: 1.5, // 50% revenue bonus
                desc: 'Calculated and meticulous. Maximizes every dollar.'
            }
        };


        let gameState = {
            playerName: 'CEO',
            selectedCharacterKey: 'CEO', // Track active character
            isRunning: false,
            netIncome: 0,
            strikes: 0,
            baseSpeed: characterTemplates['CEO'].baseSpeed,
            gameSpeed: characterTemplates['CEO'].baseSpeed, 
            itemSpawnRate: 1500, 
            lastTime: 0,
            timeSinceLastItem: 0,
            animationFrameId: null,
            maxStrikes: 3,
            
            // Power-up States
            isInvincible: false, 
            invincibilityTimer: 0, 
            isJumpBoosted: false, 
            jumpBoostTimer: 0,
            isSpeedBoosted: false,
            speedBoostTimer: 0
        };

        const player = {
            x: 50,
            y: GROUND_Y - 50,
            width: 50,
            height: 50,
            isJumping: false,
            isDucking: false,
            yVelocity: 0,
            gravity: 1.8,
            jumpStrength: INITIAL_JUMP_STRENGTH, 
            initialHeight: 50,
            duckHeight: 25
        };

        const items = [];
        const itemTemplates = [
            // Revenue (Collectibles)
            // Sales coin grants a JUMP boost
            { type: 'Revenue', label: 'Sales', value: 150, emoji: 'üíµ', color: '#fcd34d', isCollectible: true, width: 30, height: 30, yOffset: 130, draw: drawEmoji, isJumpBoost: true },
            // Stock Gain grants a SPEED boost (New item)
            { type: 'Revenue', label: 'Stock Gain', value: 200, emoji: 'üìà', color: '#4ade80', isCollectible: true, width: 35, height: 35, yOffset: 90, draw: drawEmoji, isSpeedBoost: true, spawnChance: 0.1 },
            // Dividends (Standard coin)
            { type: 'Revenue', label: 'Dividends', value: 50, emoji: 'üí∞', color: '#f59e0b', isCollectible: true, width: 25, height: 25, yOffset: 90, draw: drawEmoji },
            
            // COGS (Obstacles)
            // Server Crash (New Ground Obstacle)
            { type: 'COGS', label: 'Server Crash', value: -100, emoji: '‚ö†Ô∏è', color: '#9d3110', isCollectible: false, width: 45, height: 45, yOffset: 50, draw: drawEmoji },
            
            // Operating Expenses (Obstacles)
            // Debt Interest (New Flying Obstacle)
            { type: 'OpEx', label: 'Debt Interest', value: -150, emoji: 'üìâ', color: '#dc2626', isCollectible: false, width: 40, height: 40, yOffset: 120, draw: drawEmoji },

            // Major Loss (Strike)
            { type: 'MajorLoss', label: 'Market Turmoil', value: -500, emoji: 'üí•', color: '#7f1d1d', isCollectible: false, width: 60, height: 60, isMajor: true, strike: true, yOffset: 60, draw: drawEmoji },
            
            // Power-up (Invincibility)
            { type: 'PowerUp', label: 'Tax Shield', value: 500, emoji: 'üõ°Ô∏è', color: '#2563eb', isCollectible: true, width: 40, height: 40, yOffset: 150, draw: drawEmoji, isPowerUp: true, spawnChance: 0.03 } 
        ];

        // --- DRAWING SHAPES (using Emojis for fun design) ---
        
        function drawEmoji(item) {
            ctx.save();
            ctx.font = `${item.width}px Arial`; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(item.emoji, item.x + item.width / 2, item.y + item.height / 2);
            ctx.restore();
        }

        function drawPlayer() {
            ctx.save();
            
            let emoji = characterTemplates[gameState.selectedCharacterKey].emoji;
            let size = player.width * 1.5; 
            let yOffset = player.y + player.height;

            if (gameState.isInvincible) {
                // Pulse effect for Invincibility
                const pulse = gameState.invincibilityTimer % 150 < 75;
                const auraColor = pulse ? '#3b82f6' : '#fde047';
                ctx.fillStyle = auraColor;
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, yOffset - player.height / 2, player.width * 0.7, 0, Math.PI * 2);
                ctx.fill();
            } else if (gameState.isJumpBoosted) {
                // Up arrow effect for Jump Boost
                ctx.font = '20px Inter';
                ctx.fillStyle = '#fde047';
                ctx.textAlign = 'center';
                ctx.fillText('‚¨ÜÔ∏è', player.x + player.width / 2, player.y - 10);
            } else if (gameState.isSpeedBoosted) {
                // Bolt effect for Speed Boost
                ctx.font = '20px Inter';
                ctx.fillStyle = '#4ade80';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö°', player.x + player.width / 2, player.y - 10);
            }


            // Draw the Character Emoji
            ctx.font = `${size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(emoji, player.x + player.width / 2, yOffset);
            
            ctx.restore();
        }

        function drawParallaxBackground() {
            const width = canvas.width;
            const height = canvas.height;
            
            // 1. Distant City/Horizon (Slowest)
            const cityColor = '#4b5563';
            const cityY = GROUND_Y - 150;
            const citySpeed = gameState.gameSpeed * 0.05; // Slower parallax
            backgroundScroll.city -= citySpeed;
            if (backgroundScroll.city <= -width) backgroundScroll.city += width;

            ctx.fillStyle = cityColor;
            for (let i = 0; i < 2; i++) {
                const x = backgroundScroll.city + i * width;
                // Simplified drawing of buildings
                ctx.fillRect(x + 50, cityY - 20, 30, 20);
                ctx.fillRect(x + 100, cityY - 60, 40, 60);
                ctx.fillRect(x + 300, cityY - 80, 50, 80);
            }

            // 2. Rolling Hills (Medium Speed)
            const hillColor = '#6b7280';
            const hillY = GROUND_Y - 40;
            const hillSpeed = gameState.gameSpeed * 0.15;
            backgroundScroll.hills -= hillSpeed;
            if (backgroundScroll.hills <= -width) backgroundScroll.hills += width;
            
            ctx.fillStyle = hillColor;
            // Draw simple rounded hills
            for (let i = 0; i < 3; i++) {
                 const x = backgroundScroll.hills + i * (width / 2);
                 ctx.beginPath();
                 ctx.arc(x, hillY, 150, 0, Math.PI, true);
                 ctx.fill();
            }
        }

        function drawGround() {
            const width = canvas.width;
            const height = canvas.height;
            const roadSpeed = gameState.gameSpeed * 1.5;
            
            // 1. Solid Road
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, GROUND_Y, width, height - GROUND_Y);

            // 2. Road Lines (Fastest scrolling element)
            const lineHeight = 5;
            const lineGap = 40;
            const lineLength = 20;

            backgroundScroll.road -= roadSpeed;
            if (backgroundScroll.road <= -lineGap) backgroundScroll.road += lineGap;

            ctx.fillStyle = '#fde047'; 
            for (let i = 0; i < width / lineGap + 2; i++) {
                const x = (i * lineGap) + backgroundScroll.road;
                ctx.fillRect(x, GROUND_Y + 20, lineLength, lineHeight);
            }
        }

        function drawItems() {
            items.forEach(item => {
                // Call the generic emoji drawing function
                drawEmoji(item);
                
                // Draw label/value
                ctx.fillStyle = item.value > 0 ? '#059669' : '#b91c1c'; 
                ctx.font = 'bold 10px Inter';
                ctx.textAlign = 'center';
                const baseValue = Math.abs(item.value);
                const actualValue = item.isCollectible ? baseValue * characterTemplates[gameState.selectedCharacterKey].incomeMultiplier : baseValue;
                const displayText = item.value > 0 ? `+$${Math.round(actualValue)}` : `-$${Math.round(actualValue)}`;
                
                ctx.fillText(item.label, item.x + item.width / 2, item.y - 15);
                ctx.fillText(displayText, item.x + item.width / 2, item.y - 5);
            });
        }
        
        function drawFloatingText() {
            for (let i = FLOATING_TEXTS.length - 1; i >= 0; i--) {
                const textObj = FLOATING_TEXTS[i];
                textObj.life--;
                textObj.y -= 1.5; 
                textObj.opacity = textObj.life / 100; 

                ctx.fillStyle = textObj.color.replace(')', `, ${textObj.opacity})`);
                ctx.font = 'bold 22px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(textObj.text, textObj.x, textObj.y);

                if (textObj.life <= 0) {
                    FLOATING_TEXTS.splice(i, 1);
                }
            }
        }


        function updateScoreboard() {
            const char = characterTemplates[gameState.selectedCharacterKey];
            playerNameDisplay.textContent = `Player: ${char.emoji} ${gameState.playerName}`;
            netIncomeDisplay.textContent = `Net Income: $${gameState.netIncome.toLocaleString()}`;
            strikesDisplay.textContent = `Losses: ${gameState.strikes} / ${gameState.maxStrikes}`;

            // Update color based on score
            if (gameState.netIncome >= 1000) {
                netIncomeDisplay.className = 'text-lg font-bold text-green-400 text-center';
            } else if (gameState.netIncome < 0) {
                netIncomeDisplay.className = 'text-lg font-bold text-red-500 text-center';
            } else {
                netIncomeDisplay.className = 'text-lg font-bold text-yellow-400 text-center';
            }
            
            // Show power-up statuses
            if (gameState.isInvincible) {
                 netIncomeDisplay.textContent += ` (üõ°Ô∏è ${Math.ceil(gameState.invincibilityTimer / 1000)}s)`;
            } else if (gameState.isJumpBoosted) {
                 netIncomeDisplay.textContent += ` (‚¨ÜÔ∏è ${Math.ceil(gameState.jumpBoostTimer / 1000)}s)`;
            } else if (gameState.isSpeedBoosted) {
                 netIncomeDisplay.textContent += ` (‚ö° ${Math.ceil(gameState.speedBoostTimer / 1000)}s)`;
            }
        }

        // --- GAME MECHANICS ---

        function spawnItem() {
            // Determine spawn probability based on power-up chances
            let availableTemplates = itemTemplates.filter(t => !t.isPowerUp || Math.random() < (t.spawnChance || 0.05));
            if (availableTemplates.length === 0) availableTemplates = itemTemplates.filter(t => !t.isPowerUp); 

            const template = availableTemplates[Math.floor(Math.random() * availableTemplates.length)];
            
            const newItem = {
                ...template,
                x: canvas.width,
                y: GROUND_Y - template.yOffset, 
                width: template.width,
                height: template.height,
                collected: false
            };
            items.push(newItem);
        }

        function checkCollision(item) {
            // Check collision between player bounding box and item bounding box
            return (
                player.x < item.x + item.width &&
                player.x + player.width > item.x &&
                player.y < item.y + item.height &&
                player.y + player.height > item.y
            );
        }

        function triggerVibration(duration) {
            if ("vibrate" in navigator) {
                navigator.vibrate(duration);
            }
        }

        function handleItemEffect(item) {
            item.collected = true;
            const char = characterTemplates[gameState.selectedCharacterKey];
            let actualValue = item.value;
            let effectLabel = item.label;

            // Invincibility check: If invincible, only process positive effects
            if (!item.isCollectible && gameState.isInvincible) {
                FLOATING_TEXTS.push({ 
                    x: item.x + item.width / 2, 
                    y: item.y, 
                    text: 'SHIELDED!', 
                    color: 'rgba(59, 130, 246', 
                    life: 90 
                });
                triggerVibration(50); 
                return;
            }
            
            // Apply multiplier for collectibles (Revenue)
            if (item.isCollectible) {
                actualValue = Math.round(item.value * char.incomeMultiplier);
            }

            // Apply value change to Net Income
            gameState.netIncome += actualValue;
            
            // Create floating text feedback
            const textValue = actualValue > 0 ? `+$${actualValue}` : `-$${Math.abs(actualValue)}`;
            const textColor = actualValue > 0 ? 'rgba(16, 185, 129' : 'rgba(239, 68, 68';

            FLOATING_TEXTS.push({ 
                x: player.x + player.width / 2, 
                y: player.y, 
                text: `${effectLabel} ${textValue}`, 
                color: textColor, 
                life: 120 
            });


            // --- POWER UP EFFECTS ---
            if (item.isPowerUp) {
                // Invincibility Power-up
                gameState.isInvincible = true;
                gameState.invincibilityTimer = 5000; 
                triggerVibration(300); 
                FLOATING_TEXTS.push({ 
                    x: player.x + player.width / 2, 
                    y: player.y - 40, 
                    text: 'SHIELD ACTIVE!', 
                    color: 'rgba(59, 130, 246', 
                    life: 180 
                });
            }
            
            if (item.isJumpBoost) {
                // Jump Boost Power-up (from Sales)
                gameState.isJumpBoosted = true;
                gameState.jumpBoostTimer = 3000; // 3 seconds boost
                player.jumpStrength = BOOST_JUMP_STRENGTH;
                triggerVibration(100); 
                FLOATING_TEXTS.push({ 
                    x: player.x + player.width / 2, 
                    y: player.y - 40, 
                    text: 'JUMP BOOST!', 
                    color: 'rgba(252, 211, 77', 
                    life: 180 
                });
            }
            
            if (item.isSpeedBoost) {
                // Speed Boost Power-up (from Stock Gain)
                gameState.isSpeedBoosted = true;
                gameState.speedBoostTimer = 3000; // 3 seconds boost
                gameState.gameSpeed = gameState.baseSpeed * SPEED_BOOST_FACTOR;
                triggerVibration(100); 
                FLOATING_TEXTS.push({ 
                    x: player.x + player.width / 2, 
                    y: player.y - 40, 
                    text: 'SPEED BOOST!', 
                    color: 'rgba(74, 222, 128', 
                    life: 180 
                });
            }


            if (item.strike) {
                gameState.strikes++;
                canvas.style.backgroundColor = '#fef2f2'; 
                setTimeout(() => canvas.style.backgroundColor = '#ffffff', 100);
                triggerVibration(500); 
            } else if (item.value > 0) {
                 canvas.style.backgroundColor = '#ecfdf5'; 
                setTimeout(() => canvas.style.backgroundColor = '#ffffff', 50);
            }
        }

        function updatePlayer() {
            // Apply gravity/jump
            if (player.isJumping) {
                player.yVelocity += player.gravity;
                player.y += player.yVelocity;
            }

            if (player.y >= GROUND_Y - player.height) {
                player.isJumping = false;
                player.yVelocity = 0;
                player.y = GROUND_Y - player.height; 
            }

            // Handle ducking dimensions
            const newHeight = player.isDucking ? player.duckHeight : player.initialHeight;
            if (newHeight !== player.height) {
                player.y += (player.height - newHeight);
                player.height = newHeight;
            }
            if (!player.isJumping) {
                player.y = GROUND_Y - player.height;
            }
        }

        function updateItems(deltaTime) {
            gameState.timeSinceLastItem += deltaTime;
            if (gameState.timeSinceLastItem > gameState.itemSpawnRate) {
                spawnItem();
                // Spawn rate is inversely proportional to current game speed
                gameState.itemSpawnRate = Math.random() * 800 + 800 - (gameState.gameSpeed * 10);
                gameState.timeSinceLastItem = 0;
            }
            
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.x -= gameState.gameSpeed;

                if (!item.collected && checkCollision(item)) {
                    handleItemEffect(item);
                }

                if (item.x + item.width < 0 || item.collected) {
                    items.splice(i, 1);
                }
            }
        }
        
        function updateInvincibility(deltaTime) {
            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= deltaTime;
                if (gameState.invincibilityTimer <= 0) {
                    gameState.isInvincible = false;
                    gameState.invincibilityTimer = 0;
                }
            }
        }

        function updateJumpBoost(deltaTime) {
            if (gameState.isJumpBoosted) {
                gameState.jumpBoostTimer -= deltaTime;
                if (gameState.jumpBoostTimer <= 0) {
                    gameState.isJumpBoosted = false;
                    gameState.jumpBoostTimer = 0;
                    // Reset jump strength to character's base strength
                    player.jumpStrength = characterTemplates[gameState.selectedCharacterKey].baseJumpStrength; 
                }
            }
        }
        
        function updateSpeedBoost(deltaTime) {
            if (gameState.isSpeedBoosted) {
                gameState.speedBoostTimer -= deltaTime;
                if (gameState.speedBoostTimer <= 0) {
                    gameState.isSpeedBoosted = false;
                    gameState.speedBoostTimer = 0;
                    // Reset game speed to character's current base speed (which includes gradual acceleration)
                    gameState.gameSpeed = gameState.baseSpeed;
                } else {
                    // Keep game speed boosted while active, but allow gradual base speed increase to still affect the overall velocity
                    gameState.gameSpeed = gameState.baseSpeed * SPEED_BOOST_FACTOR;
                }
            }
        }


        // --- INPUTS & CONTROLS ---

        function jump() {
            if (!player.isJumping && gameState.isRunning) {
                player.isJumping = true;
                player.yVelocity = player.jumpStrength; 
                player.isDucking = false;
                triggerVibration(20);
            }
        }
        
        function duck() {
            if (gameState.isRunning && !player.isJumping) {
                player.isDucking = true;
            }
        }
        
        function unduck() {
            player.isDucking = false;
        }

        // Desktop Key Controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                jump();
            } else if (e.code === 'ArrowDown') {
                e.preventDefault();
                duck();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowDown') {
                e.preventDefault();
                unduck();
            }
        });

        // Mobile Touch Controls
        canvas.addEventListener('touchstart', (e) => {
            if (!gameState.isRunning) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touchY = e.touches[0].clientY - rect.top;
            
            if (touchY < canvas.height / 2) {
                jump();
            } else {
                duck();
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            unduck();
        });


        // --- GAME FLOW CONTROL ---

        function showOverlay(title, contentHTML, buttonText, buttonAction) {
            messageBox.innerHTML = `
                <h2 class="text-3xl font-black text-gray-800 mb-4">${title}</h2>
                <div class="text-gray-600 mb-6">${contentHTML}</div>
                <button id="overlayButton" class="btn-game bg-teal-600 hover:bg-teal-700 text-white font-bold rounded-lg shadow-lg">
                    ${buttonText}
                </button>
            `;
            document.getElementById('overlayButton').addEventListener('click', buttonAction);
            gameOverlay.style.opacity = 1;
            gameOverlay.style.pointerEvents = 'auto';
        }
        
        function showNameInput() {
            showOverlay(
                'Welcome, CEO!',
                `
                    <p class="mb-4">Enter your name to start your quarter on **The Profit Path**.</p>
                    <input type="text" id="nameInput" placeholder="Your Name" value="${gameState.playerName}" 
                           class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-teal-500 text-center font-bold text-gray-800">
                `,
                'Choose Your Role',
                () => {
                    const name = document.getElementById('nameInput').value.trim();
                    if (name) {
                        gameState.playerName = name.substring(0, 15);
                        showCharacterSelection();
                    } else {
                        messageBox.querySelector('p').innerHTML = '<p class="text-red-500 mb-4 font-bold">Please enter a name to start!</p>';
                    }
                }
            );
        }
        
        function showCharacterSelection() {
            let characterCards = '';
            let selectedKey = gameState.selectedCharacterKey;

            Object.keys(characterTemplates).forEach(key => {
                const char = characterTemplates[key];
                const isSelected = key === selectedKey ? 'selected' : '';
                
                characterCards += `
                    <div class="char-card ${isSelected} p-4 border-2 border-gray-200 rounded-xl text-center" data-key="${key}">
                        <div class="text-5xl mb-2">${char.emoji}</div>
                        <h4 class="text-xl font-bold text-gray-800">${char.name}</h4>
                        <p class="text-sm text-gray-500 mt-1 h-10">${char.desc}</p>
                    </div>
                `;
            });
            
            const selectionHTML = `
                <p class="text-lg mb-4 text-gray-700">Select your financial role:</p>
                <div id="characterGrid" class="grid grid-cols-3 gap-4">
                    ${characterCards}
                </div>
            `;
            
            showOverlay(
                'Choose Your Champion',
                selectionHTML,
                'View Rules',
                showRules
            );
            
            // Add click listeners for character selection
            document.querySelectorAll('.char-card').forEach(card => {
                card.addEventListener('click', () => {
                    document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    gameState.selectedCharacterKey = card.dataset.key;
                });
            });
        }


        function showRules() {
            const rulesHTML = `
                <div class="text-left space-y-3 font-semibold text-gray-700 text-sm sm:text-base">
                    <p class="text-xl text-teal-600 font-extrabold text-center">Quarterly Objectives (Rules):</p>
                    <ul class="list-disc list-inside space-y-2 pl-4">
                        <li>üí∞ **Revenue (Coins):** **Jump (Tap Top)** to collect. Increases Net Income.</li>
                        <li>üöÄ **Sales (üíµ):** Grants high revenue AND a temporary **Jump Boost** (Higher Jump).</li>
                        <li>‚ö° **Stock Gain (üìà):** Grants high revenue AND a temporary **Speed Boost** (Faster Running).</li>
                        <li>üß± **Expenses (‚ö†Ô∏è/üìâ):** **Avoid** by Jumping or Ducking.</li>
                        <li>üõ°Ô∏è **Tax Shield (Blue Diamond):** Grants bonus revenue and temporary **Invincibility**.</li>
                        <li>üí• **Major Losses:** Hitting one gives you **1 Strike** (Max 3).</li>
                    </ul>
                    <p class="text-base text-red-600 font-bold mt-4 text-center">Goal: Maximize Net Income!</p>
                </div>
            `;
            showOverlay(
                'Financial Strategy',
                rulesHTML,
                'Start Quarter',
                startGame
            );
        }
        
        function showGameOver() {
            const finalScoreClass = gameState.netIncome >= 0 ? 'text-green-600' : 'text-red-600';
            const reason = gameState.strikes >= gameState.maxStrikes 
                ? 'Reason: Too many Major Loss Strikes!' 
                : 'Reason: Net Income fell too low!';
            
            const scoreboardHTML = `
                <div class="p-4 rounded-lg bg-gray-100 border border-gray-300">
                    <p class="text-xl font-bold text-gray-800">${gameState.playerName}'s Final Results (${characterTemplates[gameState.selectedCharacterKey].name}):</p>
                    <h3 class="text-5xl font-extrabold ${finalScoreClass} my-4">$${gameState.netIncome.toLocaleString()}</h3>
                    <p class="text-base text-gray-600">${reason}</p>
                    <p class="text-sm text-red-500 mt-2">Total Major Losses: ${gameState.strikes}</p>
                </div>
            `;

            showOverlay(
                'Quarter Ended!',
                scoreboardHTML,
                'Restart Business (Keep Character)',
                startGame
            );
        }

        function gameOver() {
            gameState.isRunning = false;
            cancelAnimationFrame(gameState.animationFrameId);
            showGameOver();
        }

        function resetGame() {
            const char = characterTemplates[gameState.selectedCharacterKey];

            gameState.netIncome = 0;
            gameState.strikes = 0;
            gameState.baseSpeed = char.baseSpeed;
            gameState.gameSpeed = char.baseSpeed; 
            gameState.lastTime = 0;
            gameState.timeSinceLastItem = 0;
            
            // Reset all power-up states
            gameState.isInvincible = false;
            gameState.invincibilityTimer = 0;
            gameState.isJumpBoosted = false;
            gameState.jumpBoostTimer = 0;
            gameState.isSpeedBoosted = false;
            gameState.speedBoostTimer = 0;
            
            player.jumpStrength = char.baseJumpStrength; // Set player's base jump strength based on character

            items.length = 0;
            FLOATING_TEXTS.length = 0;
            backgroundScroll = { city: 0, hills: 0, road: 0 };
            
            player.isJumping = false;
            player.isDucking = false;
            player.y = GROUND_Y - player.height;
            player.yVelocity = 0;
            
            updateScoreboard();
        }
        
        function startGame() {
            resetGame();
            gameState.isRunning = true;
            gameOverlay.style.opacity = 0;
            gameOverlay.style.pointerEvents = 'none';
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- MAIN GAME LOOP ---

        function gameLoop(currentTime) {
            if (!gameState.isRunning) return;

            const deltaTime = currentTime - gameState.lastTime;
            gameState.lastTime = currentTime;
            
            const dtSeconds = deltaTime / 1000;

            // 1. Update Game State
            updateInvincibility(deltaTime);
            updateJumpBoost(deltaTime); 
            updateSpeedBoost(deltaTime); // NEW: Update speed boost
            updatePlayer();
            updateItems(deltaTime);
            updateScoreboard();
            
            // Gradual acceleration is applied to the BASE speed
            gameState.baseSpeed += 0.3 * dtSeconds; 
            
            // If not speed boosted, the gameSpeed equals the accelerating baseSpeed
            if (!gameState.isSpeedBoosted) {
                gameState.gameSpeed = gameState.baseSpeed;
            } else {
                // If speed boosted, update the boosted speed based on the accelerating baseSpeed
                gameState.gameSpeed = gameState.baseSpeed * SPEED_BOOST_FACTOR;
            }


            // 2. Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 3. Draw Elements 
            drawParallaxBackground();
            drawGround(); 
            drawItems();
            drawPlayer();
            drawFloatingText(); 
            
            // 4. Check for Game Over Conditions
            if (gameState.strikes >= gameState.maxStrikes || gameState.netIncome < -2000) {
                return gameOver();
            }

            // 5. Request next frame
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- INITIALIZATION ---

        window.onload = function() {
            const updateCanvasSize = () => {
                const container = document.querySelector('.w-full.max-w-4xl');
                if (container) {
                    canvas.width = container.clientWidth;
                    canvas.height = Math.min(400, container.clientWidth * 0.5); 
                    
                    GROUND_Y = canvas.height - 50;
                    player.y = GROUND_Y - player.height;
                }
            };

            updateCanvasSize();
            window.addEventListener('resize', updateCanvasSize);

            drawParallaxBackground();
            drawGround();
            drawPlayer(); 
            
            showNameInput();
        };
    </script>
</body>
</html>
